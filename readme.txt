ת.ז: 302309513
הפרוייקט נוצר ונערך ע"י נתנאל זפקו
לקובץ מצורף "input example.txt"
זהו קובץ הדוגמה שהוכן ע"י שי אוהב ציון, ולפיו עבדתי וניתחתי את הפרוייקט.
על מנת לבדוק אותו, יש לשנות את שמו ל-input.txt
בנוסף, מצורף הקובץ "output example.txt" - שהוא התוצאה הצפויה של הרצה על אותו הקובץ - אותו הפקתי ע"י הרצת הקוד.
הקובץ input.txt הוא הקובץ אותו בוריס - מרצה הקורס סיפק, ועליו בחנתי את הזמנים ואת העבודה.

הסבר וניתוח:
העבודה מחולקת ל3 שלבים עיקריים:
1. קריאה מהקובץ
2. שליחת נתונים ממחשב למחשב
3. עבודה (מציאת אובייקטים בתמונות)
בכל שלב הזמן מחושב בנפרד, ובסוף כל תהליך הזמן מוצג על המסך, ובסוף העבודה מוצג הזמן הכולל המסכם את כל השלושה.

מקבול העבודה נעשה ע"י חלוקת התמונות בין 2 הפרוססים (מעתה והלאה - בהנחה שהם על מחשבים שונים).
הקריאה עצמה מהקובץ איננה תהליך בר-מקבול,
אך בקובץ הדוגמה של שי אוהב-ציון ישנה קריאה מלאה של קובץ הכולל 2 תמונות בגדלים 551x551, וגם 724x724, וגם 6 אובייקטים בגדלים ריבועיים שך 55, 89, 26, 76, 36, 20
בסה"כ כמות זמן של כ0.06 שניות, ועל כן אני מחשיב את הזמן להיות זניח.

החלוקה נעשית בהנחה שההבדל בין גודל התמונות הוא זניח, ולכן ניתן לשלוח למחשב השני את החצי הראשון של המערך - בעוד המחשב הקורא יעבוד על החצי השני של המערך.
אין ברירה אלא לשלוח בנוסף לכך את כל האובייקטים עצמם, על מנת שנוכל למצוא אותם (אחרת עשוי לפספס אובייקט בתמונה).
השליחה עצמה יחסית קצרה (כ-0.004 שניות).
אך מכאן מתחילה העבודה עצמה; העבודה היא כמובן החלק העיקרי, הכבד והאיטי ביותר.
על מנת לחשב כל פוזיציה של חפץ בכל תמונה, החישוב נעשה במקביל על כל התמונות בעזרת OMP, כאשר מספר ה-threads מוגדר להיות 8 (המספר האופטימלי ע"י ניסוי בפועל, וגם במהלך שיעורי הבית בכיתה), אם יש יותר מ8 תמונות - באופן שבו OMP עובד, יעבוד מספר מתאים של threads, ואם 8 או יותר - אז ה8 יתחלקו בעבודה.
אם כי כפי שנלמד בקורס, ניתן להסיר את ההגדרה עצמה, כך שהמחשב יבחר את מספר הthreads להיות מספר הליבות שיש לו, כברירת מחדל. הבדלי הזמנים לא גדולים, אך ברי-הבחנה, ולכן בחרתי להישאר עם 8 threads.

במהלך השוואת אובייקט על תמונה בפוזיציה מסויימת לאחר כל שורה נעשית בדיקה אם יש טעם להמשיך בבדיקת הפוזיציה המסויימת
(לא ניתן לקטוע קטע קוד של parallel for בעזרת break, ולכן הבדיקה נעשית אך ורק אחרי כל שורה). על מנת לזרז את החישוב של כל שורה, במידה והערך סף קטן מהסכום, כל איטרציה של הלולאה מדלגת על החישוב עצמו, כדי לזרז את סיום החישוב, ומעבר לפוזיציה הבאה).
בנוסף, את החיבור של הערכים בעזרת parallel for, ועם reduction של חיבור ניסיתי במספר דרכים, אך גיליתי שהדבר תמיד יאט את התוכנית, לפעמים עד כדי פי מאה.

במהלך העבודה, המחשב השני בודק אם נמצא אובייקט או לא, ושולח 1 או 0 בהתאמה למחשב הקורא, ולפי המספר יידע אם עליו לקבל מהמחשב השני-
אם מצא: את ה-ID של התמונה, את ה-ID של האובייקט, ערך X, וערך Y של המיקום,
ואם לא מצא: את ה-ID של התמונה.
ובהתאם לכתוב את התשובה אל הקובץ.

מכיוון ששליחה ב-MPI היא לא פעולה "תוקעת", אבל קריאה היא כן, המחשב השני שולח את התוצאות עבור כל תמונה שיסיים לבדוק, וימשיך בעבודה,
בזמן שהמחשב הקורא יעבוד על כל התמונות שלו, ויתעלם מהמחשב השני. רק אחרי שיסיים לעבוד על כל התמונות ויכתוב אותן אל הקובץ - יעבור לטפל בקריאת התשובות שהמחשב השני שולח, וכך נמנע ממצב שבו מי מהמחשבים נתקע כי הוא מחכה למחשב אחר.